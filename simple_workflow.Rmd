---
title: "A Simple Workflow"
author: "Simon Goring, Socorro Dominguez Vidana"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup}
options(warn = -1)
suppressMessages(library(neotoma2))
suppressMessages(library(sf))
suppressMessages(library(geojsonsf))
suppressMessages(library(dplyr))
suppressMessages(library(ggplot2))
suppressMessages(library(leaflet))
```

## Site Searches

### `get_sites()`

There are several ways to find sites in `neotoma2`, but we think of `sites` as being spatial objects primarily. They have names, locations, and are found within the context of geopolitical units, but within the API and the package, the site itself does not have associated information about taxa, dataset types or ages.  It is simply the container into which we add that information.  So, when we search for sites we can search by:

  * siteid
  * sitename
  * location
  * altitude (maximum and minimum)
  * geopolitical unit

#### Site names: `sitename="%Lait%"`

We may know exactly what site we're looking for ("Lac Mouton"), or have an approximate guess for the site name (for example, we know it's something like "Lait Lake", or "Lac du Lait", but we're not sure how it was entered specifically).

We use the general format: `get_sites(sitename="XXXXX")` for searching by name.

PostgreSQL (and the API) uses the percent sign as a wildcard.  So `"%Lait%"` would pick up ["Lac du Lait"](https://data.neotomadb.org/4180) for us (and would pick up "Lake Lait" and "This Old **Lait**y Hei-dee-ho Bog" if they existed).  Note that the search query is also case insensitive, so you could simply write `"%lait%"`.

```{r sitename}
spo_sites <- neotoma2::get_sites(sitename = "%Lait%")
spo_sites
plotLeaflet(spo_sites)
```

#### Location: `loc=c()`

The `neotoma` package used a bounding box for locations, structured as a vector of latitude and longitude values: `c(xmin, xmax, ymin, ymax)`.  The `neotoma2` R package supports both this simple bounding box, but also more complex spatial objects, using the [`sf` package](https://r-spatial.github.io/sf/). Using the `sf` package allows us to more easily work with raster and polygon data in R, and to select sites from more complex spatial objects.  The `loc` parameter works with the simple vector, [WKT](https://arthur-e.github.io/Wicket/sandbox-gmaps3.html), [geoJSON](http://geojson.io/#map=2/20.0/0.0) objects and native `sf` objects in R.  **Note however** that the `neotoma2` package is a wrapper for a simple API call using a URL ([api.neotomadb.org](https://api.neotomadb.org)), and URL strings can only be 1028 characters long, so the API cannot accept very long/complex spatial objects.

Looking for sites using a location:

```{r boundingBox}
cz <- list(geoJSON = '{"type": "Polygon",
        "coordinates": [[
            [12.40, 50.14],
            [14.10, 48.64],
            [16.95, 48.66],
            [18.91, 49.61],
            [15.24, 50.99],
            [12.40, 50.14]]]}',
        WKT = 'POLYGON ((12.4 50.14, 
                         14.1 48.64, 
                         16.95 48.66, 
                         18.91 49.61,
                         15.24 50.99,
                         12.4 50.14))',
        bbox = c(48.64, 50.99, 12.4, 18.91))

cz$sf <- geojsonsf::geojson_sf(cz$geoJSON)

cz_sites <- neotoma2::get_sites(loc = cz[[1]])
```

You can always simply `plot()` the `sites` objects, but you will lose some of the geographic context.  The `plotLeaflet()` function returns a `leaflet()` map, and allows you to further customize it, or add additional spatial data (like our original bounding polygon):

```{r plotL}
neotoma2::plotLeaflet(cz_sites) %>% 
  leaflet::addPolygons(data = cz$sf, color = "green")
```

#### Site Helpers


We can see the different elements that are contained within this sites object:

```{r summary_sites}
head(as.data.frame(neotoma2::summary(cz_sites)))
```

### Searching for datasets:

```{r datasettype}
pollen_ds <- neotoma2::get_datasets(datasettype='pollen surface sample', limit=1000)
head(as.data.frame(pollen_ds))
```


```{r summary_ds}
head(as.data.frame(neotoma2::summary(pollen_ds)))
```
```{r downloads}
cz_dl <- neotoma2::get_downloads(cz_sites)
head(as.data.frame(neotoma2::summary(cz_dl)))
```


Let's say we only want to keep pollen datsets
```{r filtering}
cz_pollen <- cz_dl %>% neotoma2::filter(datasettype == 'pollen')
head(as.data.frame(neotoma2::summary(cz_pollen)))
```

Getting taxa:

```{r taxa}
head(as.data.frame(neotoma2::taxa(cz_pollen)))
```

We can do also for one element:
```{r taxa2}
head(as.data.frame(neotoma2::taxa(cz_pollen[[1]])))
```

### Doing a Basic Analysis

1. Getting all pollen

```{r pollen}
all_pollen <- neotoma2::get_datasets(datasettype="pollen", limit = 100)
# all_pollen <- get_datasets(datasettype="pollen", all_data = TRUE) # Takes about 20+ minutes
```
_

```{r}
neotoma2::plot(all_pollen)
```
2. Getting the data
```{r dl}
pollen_dl <- neotoma2::get_downloads(all_pollen) # Takes a couple of minutes 
```

3. Get the samples

```{r samp}
pollen_samp <- neotoma2::samples(pollen_dl)
head(pollen_samp)
```

Using Spatial-based Data (July max temperature)

```{r}
spatial <- sf::st_as_sf(pollen_samp, 
                        coords = c("long", "lat"),
                        crs = "+proj=longlat +datum=WGS84")
spatial
```

```{r worldTmax}
worldTmax <- raster::getData('worldclim', var = 'tmax', res = 10)
worldTmax
```

```{r raster}
pollen_samp$tmax7 <- raster::extract(worldTmax, spatial)[,7]
head(pollen_samp)
```

#### Choosing Taxa

```{r maxsamp}
maxsamp <- pollen_samp %>% dplyr::distinct(siteid, .keep_all = TRUE) %>% 
  dplyr::select(tmax7)
head(maxsamp)
```

Top 10
```{r topten}


topten <- pollen_samp %>% 
  dplyr::group_by(variablename) %>% 
  dplyr::summarise(n = dplyr::n()) %>% 
  dplyr::arrange(desc(n))
topten
```

```{r po_subsamp}
pollen_subsamp <- pollen_samp %>% 
  dplyr::filter(variablename %in% topten$variablename[1:10])
head(pollen_subsamp)
```

Plot your results!

```{r ggplot}
ggplot() +
  geom_density(data = pollen_subsamp,
               aes(x = round(tmax7 / 10, 0)), col = 2) +
  facet_wrap(~variablename) +
  geom_density(data = maxsamp, aes(x = tmax7 / 10)) +
  xlab("Maximum July Temperature") +
  ylab("Kernel Density")
```
